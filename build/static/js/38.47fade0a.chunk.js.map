{"version":3,"sources":["../node_modules/monaco-editor/esm/vs/basic-languages/ruby/ruby.js"],"names":["__webpack_require__","r","__webpack_exports__","d","conf","language","comments","lineComment","blockComment","brackets","autoClosingPairs","open","close","surroundingPairs","tokenPostfix","keywords","keywordops","builtins","declarations","linedecls","operators","token","symbols","escape","escapes","decpart","decimal","delim","heredelim","regexpctl","regexpesc","tokenizer","root","cases","for|until|while","next","@declarations","end","@keywords","@builtins","@default","if|unless|while|until","for","@linedecls","include","@keywordops","@operators","$1","dodecl","switchTo","do","modifier","then|else|elsif|do","sstring","dstring","$#==$S3","heredoc","$2==$S2","interpolated","interpolated_compound","pregexp","$#==$S2","~[)}\\]]","~@regexpctl","regexp","regexcontrol","regexrange","regexpcomment","pstring","qstring","$#==$S4","qqstring","whitespace","comment"],"mappings":"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","file":"static/js/38.47fade0a.chunk.js","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nexport var conf = {\n  comments: {\n    lineComment: '#',\n    blockComment: ['=begin', '=end']\n  },\n  brackets: [['(', ')'], ['{', '}'], ['[', ']']],\n  autoClosingPairs: [{\n    open: '{',\n    close: '}'\n  }, {\n    open: '[',\n    close: ']'\n  }, {\n    open: '(',\n    close: ')'\n  }, {\n    open: '\"',\n    close: '\"'\n  }, {\n    open: '\\'',\n    close: '\\''\n  }],\n  surroundingPairs: [{\n    open: '{',\n    close: '}'\n  }, {\n    open: '[',\n    close: ']'\n  }, {\n    open: '(',\n    close: ')'\n  }, {\n    open: '\"',\n    close: '\"'\n  }, {\n    open: '\\'',\n    close: '\\''\n  }]\n};\n/*\r\n * Ruby language definition\r\n *\r\n * Quite a complex language due to elaborate escape sequences\r\n * and quoting of literate strings/regular expressions, and\r\n * an 'end' keyword that does not always apply to modifiers like until and while,\r\n * and a 'do' keyword that sometimes starts a block, but sometimes is part of\r\n * another statement (like 'while').\r\n *\r\n * (1) end blocks:\r\n * 'end' may end declarations like if or until, but sometimes 'if' or 'until'\r\n * are modifiers where there is no 'end'. Also, 'do' sometimes starts a block\r\n * that is ended by 'end', but sometimes it is part of a 'while', 'for', or 'until'\r\n * To do proper brace matching we do some elaborate state manipulation.\r\n * some examples:\r\n *\r\n *   until bla do\r\n *     work until tired\r\n *     list.each do\r\n *       something if test\r\n *     end\r\n *   end\r\n *\r\n * or\r\n *\r\n * if test\r\n *  something (if test then x end)\r\n *  bar if bla\r\n * end\r\n *\r\n * or, how about using class as a property..\r\n *\r\n * class Test\r\n *   def endpoint\r\n *     self.class.endpoint || routes\r\n *   end\r\n * end\r\n *\r\n * (2) quoting:\r\n * there are many kinds of strings and escape sequences. But also, one can\r\n * start many string-like things as '%qx' where q specifies the kind of string\r\n * (like a command, escape expanded, regular expression, symbol etc.), and x is\r\n * some character and only another 'x' ends the sequence. Except for brackets\r\n * where the closing bracket ends the sequence.. and except for a nested bracket\r\n * inside the string like entity. Also, such strings can contain interpolated\r\n * ruby expressions again (and span multiple lines). Moreover, expanded\r\n * regular expression can also contain comments.\r\n */\n\nexport var language = {\n  tokenPostfix: '.ruby',\n  keywords: ['__LINE__', '__ENCODING__', '__FILE__', 'BEGIN', 'END', 'alias', 'and', 'begin', 'break', 'case', 'class', 'def', 'defined?', 'do', 'else', 'elsif', 'end', 'ensure', 'for', 'false', 'if', 'in', 'module', 'next', 'nil', 'not', 'or', 'redo', 'rescue', 'retry', 'return', 'self', 'super', 'then', 'true', 'undef', 'unless', 'until', 'when', 'while', 'yield'],\n  keywordops: ['::', '..', '...', '?', ':', '=>'],\n  builtins: ['require', 'public', 'private', 'include', 'extend', 'attr_reader', 'protected', 'private_class_method', 'protected_class_method', 'new'],\n  // these are closed by 'end' (if, while and until are handled separately)\n  declarations: ['module', 'class', 'def', 'case', 'do', 'begin', 'for', 'if', 'while', 'until', 'unless'],\n  linedecls: ['def', 'case', 'do', 'begin', 'for', 'if', 'while', 'until', 'unless'],\n  operators: ['^', '&', '|', '<=>', '==', '===', '!~', '=~', '>', '>=', '<', '<=', '<<', '>>', '+', '-', '*', '/', '%', '**', '~', '+@', '-@', '[]', '[]=', '`', '+=', '-=', '*=', '**=', '/=', '^=', '%=', '<<=', '>>=', '&=', '&&=', '||=', '|='],\n  brackets: [{\n    open: '(',\n    close: ')',\n    token: 'delimiter.parenthesis'\n  }, {\n    open: '{',\n    close: '}',\n    token: 'delimiter.curly'\n  }, {\n    open: '[',\n    close: ']',\n    token: 'delimiter.square'\n  }],\n  // we include these common regular expressions\n  symbols: /[=><!~?:&|+\\-*\\/\\^%\\.]+/,\n  // escape sequences\n  escape: /(?:[abefnrstv\\\\\"'\\n\\r]|[0-7]{1,3}|x[0-9A-Fa-f]{1,2}|u[0-9A-Fa-f]{4})/,\n  escapes: /\\\\(?:C\\-(@escape|.)|c(@escape|.)|@escape)/,\n  decpart: /\\d(_?\\d)*/,\n  decimal: /0|@decpart/,\n  delim: /[^a-zA-Z0-9\\s\\n\\r]/,\n  heredelim: /(?:\\w+|'[^']*'|\"[^\"]*\"|`[^`]*`)/,\n  regexpctl: /[(){}\\[\\]\\$\\^|\\-*+?\\.]/,\n  regexpesc: /\\\\(?:[AzZbBdDfnrstvwWn0\\\\\\/]|@regexpctl|c[A-Z]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4})?/,\n  // The main tokenizer for our languages\n  tokenizer: {\n    // Main entry.\n    // root.<decl> where decl is the current opening declaration (like 'class')\n    root: [// identifiers and keywords\n    // most complexity here is due to matching 'end' correctly with declarations.\n    // We distinguish a declaration that comes first on a line, versus declarations further on a line (which are most likey modifiers)\n    [/^(\\s*)([a-z_]\\w*[!?=]?)/, ['white', {\n      cases: {\n        'for|until|while': {\n          token: 'keyword.$2',\n          next: '@dodecl.$2'\n        },\n        '@declarations': {\n          token: 'keyword.$2',\n          next: '@root.$2'\n        },\n        'end': {\n          token: 'keyword.$S2',\n          next: '@pop'\n        },\n        '@keywords': 'keyword',\n        '@builtins': 'predefined',\n        '@default': 'identifier'\n      }\n    }]], [/[a-z_]\\w*[!?=]?/, {\n      cases: {\n        'if|unless|while|until': {\n          token: 'keyword.$0x',\n          next: '@modifier.$0x'\n        },\n        'for': {\n          token: 'keyword.$2',\n          next: '@dodecl.$2'\n        },\n        '@linedecls': {\n          token: 'keyword.$0',\n          next: '@root.$0'\n        },\n        'end': {\n          token: 'keyword.$S2',\n          next: '@pop'\n        },\n        '@keywords': 'keyword',\n        '@builtins': 'predefined',\n        '@default': 'identifier'\n      }\n    }], [/[A-Z][\\w]*[!?=]?/, 'constructor.identifier'], [/\\$[\\w]*/, 'global.constant'], [/@[\\w]*/, 'namespace.instance.identifier'], [/@@[\\w]*/, 'namespace.class.identifier'], // here document\n    [/<<[-~](@heredelim).*/, {\n      token: 'string.heredoc.delimiter',\n      next: '@heredoc.$1'\n    }], [/[ \\t\\r\\n]+<<(@heredelim).*/, {\n      token: 'string.heredoc.delimiter',\n      next: '@heredoc.$1'\n    }], [/^<<(@heredelim).*/, {\n      token: 'string.heredoc.delimiter',\n      next: '@heredoc.$1'\n    }], // whitespace\n    {\n      include: '@whitespace'\n    }, // strings\n    [/\"/, {\n      token: 'string.d.delim',\n      next: '@dstring.d.\"'\n    }], [/'/, {\n      token: 'string.sq.delim',\n      next: '@sstring.sq'\n    }], // % literals. For efficiency, rematch in the 'pstring' state\n    [/%([rsqxwW]|Q?)/, {\n      token: '@rematch',\n      next: 'pstring'\n    }], // commands and symbols\n    [/`/, {\n      token: 'string.x.delim',\n      next: '@dstring.x.`'\n    }], [/:(\\w|[$@])\\w*[!?=]?/, 'string.s'], [/:\"/, {\n      token: 'string.s.delim',\n      next: '@dstring.s.\"'\n    }], [/:'/, {\n      token: 'string.s.delim',\n      next: '@sstring.s'\n    }], // regular expressions. Lookahead for a (not escaped) closing forwardslash on the same line\n    [/\\/(?=(\\\\\\/|[^\\/\\n])+\\/)/, {\n      token: 'regexp.delim',\n      next: '@regexp'\n    }], // delimiters and operators\n    [/[{}()\\[\\]]/, '@brackets'], [/@symbols/, {\n      cases: {\n        '@keywordops': 'keyword',\n        '@operators': 'operator',\n        '@default': ''\n      }\n    }], [/[;,]/, 'delimiter'], // numbers\n    [/0[xX][0-9a-fA-F](_?[0-9a-fA-F])*/, 'number.hex'], [/0[_oO][0-7](_?[0-7])*/, 'number.octal'], [/0[bB][01](_?[01])*/, 'number.binary'], [/0[dD]@decpart/, 'number'], [/@decimal((\\.@decpart)?([eE][\\-+]?@decpart)?)/, {\n      cases: {\n        '$1': 'number.float',\n        '@default': 'number'\n      }\n    }]],\n    // used to not treat a 'do' as a block opener if it occurs on the same\n    // line as a 'do' statement: 'while|until|for'\n    // dodecl.<decl> where decl is the declarations started, like 'while'\n    dodecl: [[/^/, {\n      token: '',\n      switchTo: '@root.$S2'\n    }], [/[a-z_]\\w*[!?=]?/, {\n      cases: {\n        'end': {\n          token: 'keyword.$S2',\n          next: '@pop'\n        },\n        'do': {\n          token: 'keyword',\n          switchTo: '@root.$S2'\n        },\n        '@linedecls': {\n          token: '@rematch',\n          switchTo: '@root.$S2'\n        },\n        '@keywords': 'keyword',\n        '@builtins': 'predefined',\n        '@default': 'identifier'\n      }\n    }], {\n      include: '@root'\n    }],\n    // used to prevent potential modifiers ('if|until|while|unless') to match\n    // with 'end' keywords.\n    // modifier.<decl>x where decl is the declaration starter, like 'if'\n    modifier: [[/^/, '', '@pop'], [/[a-z_]\\w*[!?=]?/, {\n      cases: {\n        'end': {\n          token: 'keyword.$S2',\n          next: '@pop'\n        },\n        'then|else|elsif|do': {\n          token: 'keyword',\n          switchTo: '@root.$S2'\n        },\n        '@linedecls': {\n          token: '@rematch',\n          switchTo: '@root.$S2'\n        },\n        '@keywords': 'keyword',\n        '@builtins': 'predefined',\n        '@default': 'identifier'\n      }\n    }], {\n      include: '@root'\n    }],\n    // single quote strings (also used for symbols)\n    // sstring.<kind>  where kind is 'sq' (single quote) or 's' (symbol)\n    sstring: [[/[^\\\\']+/, 'string.$S2'], [/\\\\\\\\|\\\\'|\\\\$/, 'string.$S2.escape'], [/\\\\./, 'string.$S2.invalid'], [/'/, {\n      token: 'string.$S2.delim',\n      next: '@pop'\n    }]],\n    // double quoted \"string\".\n    // dstring.<kind>.<delim> where kind is 'd' (double quoted), 'x' (command), or 's' (symbol)\n    // and delim is the ending delimiter (\" or `)\n    dstring: [[/[^\\\\`\"#]+/, 'string.$S2'], [/#/, 'string.$S2.escape', '@interpolated'], [/\\\\$/, 'string.$S2.escape'], [/@escapes/, 'string.$S2.escape'], [/\\\\./, 'string.$S2.escape.invalid'], [/[`\"]/, {\n      cases: {\n        '$#==$S3': {\n          token: 'string.$S2.delim',\n          next: '@pop'\n        },\n        '@default': 'string.$S2'\n      }\n    }]],\n    // literal documents\n    // heredoc.<close> where close is the closing delimiter\n    heredoc: [[/^(\\s*)(@heredelim)$/, {\n      cases: {\n        '$2==$S2': ['string.heredoc', {\n          token: 'string.heredoc.delimiter',\n          next: '@pop'\n        }],\n        '@default': ['string.heredoc', 'string.heredoc']\n      }\n    }], [/.*/, 'string.heredoc']],\n    // interpolated sequence\n    interpolated: [[/\\$\\w*/, 'global.constant', '@pop'], [/@\\w*/, 'namespace.class.identifier', '@pop'], [/@@\\w*/, 'namespace.instance.identifier', '@pop'], [/[{]/, {\n      token: 'string.escape.curly',\n      switchTo: '@interpolated_compound'\n    }], ['', '', '@pop']],\n    // any code\n    interpolated_compound: [[/[}]/, {\n      token: 'string.escape.curly',\n      next: '@pop'\n    }], {\n      include: '@root'\n    }],\n    // %r quoted regexp\n    // pregexp.<open>.<close> where open/close are the open/close delimiter\n    pregexp: [{\n      include: '@whitespace'\n    }, // turns out that you can quote using regex control characters, aargh!\n    // for example; %r|kgjgaj| is ok (even though | is used for alternation)\n    // so, we need to match those first\n    [/[^\\(\\{\\[\\\\]/, {\n      cases: {\n        '$#==$S3': {\n          token: 'regexp.delim',\n          next: '@pop'\n        },\n        '$#==$S2': {\n          token: 'regexp.delim',\n          next: '@push'\n        },\n        '~[)}\\\\]]': '@brackets.regexp.escape.control',\n        '~@regexpctl': 'regexp.escape.control',\n        '@default': 'regexp'\n      }\n    }], {\n      include: '@regexcontrol'\n    }],\n    // We match regular expression quite precisely\n    regexp: [{\n      include: '@regexcontrol'\n    }, [/[^\\\\\\/]/, 'regexp'], ['/[ixmp]*', {\n      token: 'regexp.delim'\n    }, '@pop']],\n    regexcontrol: [[/(\\{)(\\d+(?:,\\d*)?)(\\})/, ['@brackets.regexp.escape.control', 'regexp.escape.control', '@brackets.regexp.escape.control']], [/(\\[)(\\^?)/, ['@brackets.regexp.escape.control', {\n      token: 'regexp.escape.control',\n      next: '@regexrange'\n    }]], [/(\\()(\\?[:=!])/, ['@brackets.regexp.escape.control', 'regexp.escape.control']], [/\\(\\?#/, {\n      token: 'regexp.escape.control',\n      next: '@regexpcomment'\n    }], [/[()]/, '@brackets.regexp.escape.control'], [/@regexpctl/, 'regexp.escape.control'], [/\\\\$/, 'regexp.escape'], [/@regexpesc/, 'regexp.escape'], [/\\\\\\./, 'regexp.invalid'], [/#/, 'regexp.escape', '@interpolated']],\n    regexrange: [[/-/, 'regexp.escape.control'], [/\\^/, 'regexp.invalid'], [/\\\\$/, 'regexp.escape'], [/@regexpesc/, 'regexp.escape'], [/[^\\]]/, 'regexp'], [/\\]/, '@brackets.regexp.escape.control', '@pop']],\n    regexpcomment: [[/[^)]+/, 'comment'], [/\\)/, {\n      token: 'regexp.escape.control',\n      next: '@pop'\n    }]],\n    // % quoted strings\n    // A bit repetitive since we need to often special case the kind of ending delimiter\n    pstring: [[/%([qws])\\(/, {\n      token: 'string.$1.delim',\n      switchTo: '@qstring.$1.(.)'\n    }], [/%([qws])\\[/, {\n      token: 'string.$1.delim',\n      switchTo: '@qstring.$1.[.]'\n    }], [/%([qws])\\{/, {\n      token: 'string.$1.delim',\n      switchTo: '@qstring.$1.{.}'\n    }], [/%([qws])</, {\n      token: 'string.$1.delim',\n      switchTo: '@qstring.$1.<.>'\n    }], [/%([qws])(@delim)/, {\n      token: 'string.$1.delim',\n      switchTo: '@qstring.$1.$2.$2'\n    }], [/%r\\(/, {\n      token: 'regexp.delim',\n      switchTo: '@pregexp.(.)'\n    }], [/%r\\[/, {\n      token: 'regexp.delim',\n      switchTo: '@pregexp.[.]'\n    }], [/%r\\{/, {\n      token: 'regexp.delim',\n      switchTo: '@pregexp.{.}'\n    }], [/%r</, {\n      token: 'regexp.delim',\n      switchTo: '@pregexp.<.>'\n    }], [/%r(@delim)/, {\n      token: 'regexp.delim',\n      switchTo: '@pregexp.$1.$1'\n    }], [/%(x|W|Q?)\\(/, {\n      token: 'string.$1.delim',\n      switchTo: '@qqstring.$1.(.)'\n    }], [/%(x|W|Q?)\\[/, {\n      token: 'string.$1.delim',\n      switchTo: '@qqstring.$1.[.]'\n    }], [/%(x|W|Q?)\\{/, {\n      token: 'string.$1.delim',\n      switchTo: '@qqstring.$1.{.}'\n    }], [/%(x|W|Q?)</, {\n      token: 'string.$1.delim',\n      switchTo: '@qqstring.$1.<.>'\n    }], [/%(x|W|Q?)(@delim)/, {\n      token: 'string.$1.delim',\n      switchTo: '@qqstring.$1.$2.$2'\n    }], [/%([rqwsxW]|Q?)./, {\n      token: 'invalid',\n      next: '@pop'\n    }], [/./, {\n      token: 'invalid',\n      next: '@pop'\n    }]],\n    // non-expanded quoted string.\n    // qstring.<kind>.<open>.<close>\n    //  kind = q|w|s  (single quote, array, symbol)\n    //  open = open delimiter\n    //  close = close delimiter\n    qstring: [[/\\\\$/, 'string.$S2.escape'], [/\\\\./, 'string.$S2.escape'], [/./, {\n      cases: {\n        '$#==$S4': {\n          token: 'string.$S2.delim',\n          next: '@pop'\n        },\n        '$#==$S3': {\n          token: 'string.$S2.delim',\n          next: '@push'\n        },\n        '@default': 'string.$S2'\n      }\n    }]],\n    // expanded quoted string.\n    // qqstring.<kind>.<open>.<close>\n    //  kind = Q|W|x  (double quote, array, command)\n    //  open = open delimiter\n    //  close = close delimiter\n    qqstring: [[/#/, 'string.$S2.escape', '@interpolated'], {\n      include: '@qstring'\n    }],\n    // whitespace & comments\n    whitespace: [[/[ \\t\\r\\n]+/, ''], [/^\\s*=begin\\b/, 'comment', '@comment'], [/#.*$/, 'comment']],\n    comment: [[/[^=]+/, 'comment'], [/^\\s*=begin\\b/, 'comment.invalid'], [/^\\s*=end\\b.*/, 'comment', '@pop'], [/[=]/, 'comment']]\n  }\n};"],"sourceRoot":""}